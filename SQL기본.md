  

# Nologging

>   -   데이터베이스에 데이터를 입력하면 로그파일에 그정보를 기록한다
>   -   Check Point라는 이벤트가 발생하면 로그파일의 데이터를 데이터 파일에 저장한다
>   -   Nologging옵션은 로그파일의 기록을 최소화 시켜서 입력 시 성능을 향상시키는 방법이다
>   -   Nologging 옵션은 Buffer Cache라는 메모리 영역을 생략하고 기록한다

<br><br>

# 테이블 데이터 삭제

>   ### DELETE FROM 테이블명
>
>   -   테이블의 모든 데이터를 삭제한다
>   -   데이터가 삭제되어도 테이블의 용량은 감소하지 않는다
>
>   ### TRUNCATE TABLE 테이블명
>
>   -   테이블의 모든 데이터를 삭제한다
>   -   데이터가 삭제되면 테이블의 **용량은 초기화 된다**
>
>   :book: Truncate Table 명령어는 특정 행을 지우는 것이 아니라 모든 행을 제거한다.
>
>   :book: DELETE 명령어는 데이터는 지워지지만 테이블 용량은 줄어들지 않는다. 원하는 데이터만 지울 수 있다. 삭제 후 잘못 삭제한 것을 되돌릴 수 있다.
>
>   :book: TRUNCATE 명령어는 용량이 줄어 들고, 인덱스 등도 모두 삭제 된다. 테이블은 삭제하지는 않고, 데이터만 삭제한다. 한꺼번에 다 지워야 한다. 삭제 후 절대 되돌릴 수 없다
>
>   :book: DROP 명령어는 테이블 전체를 삭제, 공간, 객체를 삭제한다. 삭제 후 절대 되돌릴 수 없다.

<br><br>





# DECODE  (=IF문)

>   EMPNO와 1000이 같으면 TRUE 다르면 FALSE를 리턴한다

```mysql
DECODE(EMPNO,1000,'TRUE','FALSE')
```

<br><br>

# CASE문

>   CASE문은 IF~THEN~ELSE -END의 프로그램 언어처럼 조건문을 사용할 수 있다.
>
>   조건을 WHEN구에 사용하고 THEN은 해당 조건이 참이면 실행되고 거짓이면 ELSE구가 실행된다

```mysql
CASE [expression]
	WHEN condition_1 THEN result_1
	WHEN condition_2 THEN result_2
	...
	WHEN condition_n THEN result_n
	ELSE result
END
```

<br><br>

# SELECT 문 실행 순서

1.  FROM
2.  WHERE
3.  GROUP BY
4.  HAVING
5.  SELECT
6.  ORDER BY

<br><br>



# 인라인뷰(inline view)

>   SELECT문에서 FROM절에 사용되는 서브쿼리(Sub Query)를 의미한다

<br><br>

# ROWNUM과 ROWID

>   ### ROWNUM
>
>   -   ROWNUM은 ORACLE 데이터베이스의 SELECT문ㅇ 결과에 대해서 논리적인 일련번호를 부여한다
>
>   -   ROWNUM은 조회되는 행 수를 제한할 떄 많이 사용된다
>
>   -   ROWNUM은 화면에 데이터를 출력할 때 부여되는 논리적 순번이다. 만약 ROWNUM을 사용해서 페이지 단위 출력을 하기 위해서는 인라인 뷰(Inline view)를 사용해야 한다
>
>       #### SQL Server의 TOP구문과 MYSQL의 limit 구문
>
>       -   Oracle은 ROWNUM을 사용하지만, SQL Server는 TOP문을 사용하고 MySQL은 LIMIT구를 사용한다. 즉 10명만 인출(Fetch)하고자 할 떄에는 다음과 같이 사용한다
>
>           ```mssql
>           --SQL Server
>           SELECT TOP(10) FROM EMP;
>           --MySQL
>           SELECT * FROM EMP LIMIT10;
>           ```
>
>           
>
>   ### ROWID
>
>   -   ROWID는 ORACLE 데이터베이스 내에서 데이터를 구분할 수 있는 유일한 값이다
>   -   ROWID는 "SELECT ROWID,EMPNO FROM EMP" 와 같은 SELECT문으로 확인할 수 있다
>   -   ROWID를 통해서 데이터가 어떤 데이터파일,어느 블록에 저장되어 있는 지 알 수 있다.
>
>   | 구조           | 길이  | 설명                                                         |
>   | -------------- | ----- | ------------------------------------------------------------ |
>   | 오브젝트 번호  | 1~6   | 오브젝트(Object)별로 유일한 값을 가지고 있으며 해당 오브젝트가 속해 있는 값이다. |
>   | 상태 파일 번호 | 7~9   | 테이블스페이스(Tablespace)에 속해 있는 데이터 파일에 대한 상대 파일번호이다. |
>   | 블록 번호      | 10~15 | 데이터 파일 내부에서 어느 블록에 데이터가 있는지 알려준다    |
>   | 데이터 번호    | 16~18 | 데이터 블록에 데이터가 저장되어 있는 순서를 의미한다         |

<br><br>

# WITH구문

>   WITH구문은 서브쿼리(Subquery)를 사용해서 임시 테이블이나 뷰처럼 사용할 수 있는 구문이다
>
>   서브쿼리 블록에 별칭을 지정할 수 있다.
>
>   옵티마이저는 SQL을 인라인 뷰나 임시 테이블로 판단한다
>
>   ```mssql
>   WITH viewData AS
>   (SELECT * FROM EMP
>   	UNION ALL
>    SELECT * FROM EMP)
>    SELECT * FROM viewData WHERE EMPNO=1000;
>   ```



<br><br>

# GRANT

>   ### GRANT문
>
>   ```mssql
>   GRANT 권한 ON 테이블 TO 유저
>   ```
>
>   ### Privileges(권한)
>
>   | 권한       | 설명                                                         |
>   | ---------- | ------------------------------------------------------------ |
>   | SELECT     | SELECT권한                                                   |
>   | INSERT     | INSERT권한                                                   |
>   | UPDATE     | UPDATE권한                                                   |
>   | DELETE     | DELETE권한                                                   |
>   | REFERENCES | 지정된 테이블을 참조하는 제약조건을 생성하는 권한을 부여한다 |
>   | ALTER      | 지정된 테이블에 대해서 수정할 수 있는 권한을 부여한다        |
>   | INDEX      | 지정된 테이블에 대해서 인덱스를 생성할 수 있는 권한을 부여한다 |
>   | ALL        | 테이블에 대한 모든 권한을 부여한다                           |
>
>   
>
>   ### WITH GRANT OPTION
>
>   | GRANT 옵션        | 설명                                                         |
>   | ----------------- | ------------------------------------------------------------ |
>   | WITH GRANT OPTION | -특정 사용자에게 권한을 부여할 수 있는 권한을 부여한다<br />-권한을 A 사용자가 B에 부여하고 B가 다시 C를 부여한 후에 권한을 취소(Revoke)하면 모든 권한이 회수된다 |
>   | WITH ADMIN OPTION | -테이블에 대한 모든 권한을 부여한다<br />-권한을 A 사용자가 B에 부여하고 B가 다시 C에게 부여한 후에 권한을 취소(Revoke)하면 B사용자 권한만 취소된다 |

<br><br>

# REVOKE

>   사용자에게 부여된 권한을 회수한다
>
>   ```mssql
>   REVOKE 권한 ON 테이블 FROM 유저
>   ```

<br><br>

# TCL(Transaction Control Language)

>   ## COMMIT
>
>   -   COMMIT시 변경 전 이전 데이터는 잃어버린다. 즉, A값을 B로 변경하고 COMMIT을 하면 A값은 잃어버리고 B 값을 반영한다
>   -   다른 모든 데이터베이스 사용자는 변경된 데이터를 볼 수 있다
>   -   COMMIT이 완료되면 데이터베이스 변경으로 인한 LOCK이 해제(UNLOCK)된다.
>   -   COMMIT이 완료되면 다른 모든 데이터베이스 사용자는 변경된 데이터를 조작할 수 있다
>   -   COMMIT을 실행하면 하나의 트랜잭션 과정을 종료한다
>
>   **:book: Oracle 데이터베이스는 암시적-트랜잭션-관리를 한다 즉, Oracle 데이터베이스로 트랜잭션을 시작하고 트랜잭션의 종료는 Oracle 데이터베이스 사용자가 COMMIT 혹은 ROLL-BACK으로 처리해야 한다.** 
>
>   ##### :book: Auto commit 하는법  : "set autocommit on;"을 SQL*PLUS에서 실행하면 자동으로 COMMIT된다
>
>   ```mysql
>   commit;
>   ```
>
>    
>
>   ## ROLLBACK
>
>   -   ROLLBACK을 실행하면 데이터에 대한 변경 사용을 모두 취소하고 트랜잭션을 종료한다
>   -   INSERT, UPDATE , DELETE문의 작업을 모두 취소한다 단, 이전에 COMMIT한 곳까지만 복구한다.
>   -   ROLLBACK을 실행하면 LOCK이 해제되고 다른 사용자도 데이터베이스 행을 조작할 수 있다.
>
>   ```mysql
>   rollback;
>   ```
>
>   
>
>   
>
>   ## SAVEPOINT(저장점)
>
>   -   SAVEPOINT는 트랜잭션을 작게 분할하여 관리하는 것으로 SAVEPOINT를 사용하면 지정된 위치 이후의 트랜잭션만 ROLLBACK할 수 있다.
>
>   -   **SAVEPOINT의 지정**
>
>       -    SAVEPOINT <SAVEPOINT명>
>
>   -   ##### 지정된 SAVEPOINT까지만 데이터 변경을 취소하고 싶은 경우
>
>       -   ROLLBACK TO <SAVEPOINT명>
>
>   -   ROLLBACK을 실행하면 SAVEPOINT와 관계없이 데이터의 모든 변경사항을 저장하지 않는다 
>
>   ```mssql
>   update emp et ename='조조' where empno=1001;
>   select ename from emp where empno=1001;
>   rollback;
>   
>   
>   update emp et ename='조조' where empno=1001;
>   savepoint t1;
>   update emp set ename='관우' where empno=1003;
>   savepoint t2;
>   rollback to t2;  --savepoint t2까지 변경된 것을 최소한다 
>   ```
>
>   

<br><br>





# ROW Chaining 과 ROW Migration

| 구분   | ROW Chaining                                                 | Row Migration                                                |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 정의   | 하나의 ROW를 하나의 블록에 저장할 수 없어서 여러 블록에 걸쳐서 저장하는현상 | Update로 인하여 늘어나느 공간을 저장할 공간이 없어서 다른 블록으로Row를 옮기는 현상 |
| 특성   | Iniitial Row Piece(행조각)와 Row Pointer로 블록 내에 저장됨  | 기존 블록에는 Migration되는 데이터의 row header와 블록주소값을 갖게되고 새로운 블록에는 Migration되는 데이터가 저장됨 |
| 문제점 | Row의 정보를 검색하기 위해 하나 이상의 데이터 블록을 Scan 해야 하기 떄문에 성능이 감소됨 | Migration된 Row 를 읽기 전에 기존 블록에서 헤더를 통해 Migration된 row를 읽기 때문에 성능이 감소됨 |
| 해결책 | 블록의 크기를 크게만듦                                       | PCTFREE를 크게 설정<br />객체를 Export하고 삭제한 후 Import<br />객체를 Migration하고 Truncate |

<br><br>



# 인덱스

-   인덱스 칼럼에 형변환을 수행하면 인덱스를 사용하지 못한다(예외적인 것도 있다)
-   DML 작업은 테이블과 인덱스를 함께 변경하므로 느려지는 단점이 있다.
-   인덱스는 테이블을 기반으로 선택적으로 생성할 수 있는 구조이다

<br><br>





# PL/SQL

#### 특징

-   PL/SQL은 Block 구조로 되어있어 각기능별로 **모듈화가 가능하**다
-   변수,상수 등을 선언하며 S**QL문장 간 값을 교환**한다
-   IF,LOOP등의 절차형 언어를 사용하여 **절차적인 프로그램이 가능**하다
-   **DBMS정의 에러나 사용자 정의 에러를 정의**하여 사용할 수있다.
-   PL/SQL은 Oracle에 내장되어 있으므로 **Oracle과 PL/SQL을 지원하는 어떤 서버로도 프로그램을 옮길 수 있다.**
-   PL/SQL은 **응용 프로그램의 성능을 향상**시킨다
-   PL/SQL은 여러 SQL문장을 Block으로 묶고 한ㅂ 번에 Block 전부를 서버로 보내기 때문에 **통신량을 줄일 수 있다**

<br><br>

# Hash Join

#### 특징

-   Hash Join은 조인 칼럼의 **<u>인덱스가 존재하지 않을 경우에도 사용할 수 있는 기법</u>**이다.
-   Hash Join은 **해시 함수를 이용하여 조인을 수행하기 때문에 <u>'='로 수행하는 조인으로 동등 조건에만 사용할 수 있다.**</u>
-   해시 함수가 적용될 때 **동일한 값을 항상 같은 값으로 해싱됨**이 보장된다.
-   Hash Join 작업을 수행하기 위해 **해시 테이블을 메모리에 생성해야 한다**.
-   **메모리에 적재할 수 있는 영역에 크기보다 커지면 임시 영역(디스크)에 해시 테이블을 저장한다.**
-   Hash Join을 할 때는 **결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다**
-   **선행 테이블**을 **Build input**이라 하며, **후행 테이블**은 **Prove Input**이라 한다.

<br><br>

# Alias 적용 차이

#### Oracle

-   Alias명이 없는 칼럼명은 **대문자로 바뀐다**

#### SQL Server

-   ALias명이 없는 칼럼명을 **그대로 사용한다.**

<br><br>

# 도메인 특징

-   각 속성이 가질 수 있도록 허용된 값들의 집합
-   속성명과 도메인명이 반드시 동일할 필요는 없다
-   릴레이션에서 모든 속성들의 도메인은 원자적(Atomic)이어야 한다.
-   원자적 도메인: 도메인의 원소가 더 이상 나누어질 수 없는 단일체 일 때를 의미한다

<br><br>

# 식별자 

#### 특징

-   주시별자에 의해 엔티티 내에 **모든 인스턴스가 유일하게 구분되어야 한**다. **(유연성)**
-   주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다. **(최소성)**
-   지정된 주식별자의 **값은 자주 변하지 않는 것이어야 한다. ** **(불변성)**
-   주식별자가 **지정이 되면 반드시 값이 들어와야 한다.** **(존재성)**

<br><br>

# 칼럼의 반정규화

####  :book:빈도가 높을경우 고객과 주문 테이블의 비식별자 관계를 식별자 관계로 한다

| 반정규화 기법                      | 내용                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| 중복칼럼 추가                      | **조인에 의해 처리할 때 성능저하를 예방**하기 위해 즉 조인을 감소시키기 위해 **중복된 칼럼을 위치시킴** |
| 파생칼럼 추가                      | 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리**값을 계산하여 칼럼에 보관함 Derived Column**이라고 함 |
| 이력테이블 칼럼 추가               | **대량의 이력데이터를 처리할 때** 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 **이력테이블에 기능성 칼럼(최근값 여부,시작과 종료일자 등)을 추가함** |
| 기본키에 의한 칼럼 추가            | -**복합의미를 갖는 기본키를 단일 속성을 구성하였을 경우 발생됨**<br />-단일 기본키 안에서 특정 값을 별도로 조회하는 경우 성능저하가 발생될 수 있음. 이 때 **이미 기본키안에 데이터가 존재하지만 성능향상을 위해 일반속성으로 포함하는 방법이 기본키에 의한 칼럼추가 반정규화**이다 |
| 응용시스템 오작동을 위한 칼럼 추가 | -**업무적으로는 의미가 없지만 사용자가 데이터처리를 하다가 잘못 처리하여 원래값으로 복구하기를 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법**<br />-칼럼으로 이것을 보관하는 방법은 오작동 처리를 위한 임시적인 기법이지만 **이것을 이력데이터 모델로 풀어내면 정상적인 데이터 모델의 기법이 될 수 있음** |

<br><br>

# ROLLBACK

#### ORACLE의 경우

-   ROLLBACK이 수행되면 DDL인 CREATE  구문과 DML인 UPDATE는 묵시적으로 COMMIT이 수행되므로 취소가 되지 않는다

#### SQL SERVER일 경우

-   기본값이 AUTO COMMIT OFF로 설정된 상태에서 DDL이 수행되어도 묵시적 으로 COMMIT가 수행되지 않는다(SET IMPLICITTRANSACTIONS ON 설정 후 수행을 하면 CREATE TABLE도 최소됨

<br><br>

# Nested Loop조인

>   -   Nested Loop조인은 하나의 테이블에서 데이터를 먼저 찾고 그다음 테이블을 조인하는 방식이다
>   -   먼저 조회되는 테이블을 외부 테이블  , 다음 조회되는 테이블을 내부 테이블 이라고한다
>   -   외부테이블의 크기가 작은 것을 먼저 찾는 것이 스캔 범위를 줄이는 방법이다
>   -   Nested Loop 조인은 RANDOM ACCESS가 발생하는데 RANDOMACCESS가 많이 방생하면 성능 지연이 발생한다  , 양을 줄여야 성능이 향상된다
>
>   #### RANDOMACCESS
>
>   -   첫번째 테이블에서 두번쨰로 넘어가면서 두번째 테이블의 인덱스를 찾는 것
>
>   ### 진행과정
>
>   1.  첫번째 테이블의 인덱스를 먼저 검색하고 인덱스에 있는 ROWID를 사용해서 첫번째 테이블을 읽는다 
>   2.  그다음은 첫번째 테이블에서 두번쨰 테이블의 인덱스를 찾고 해당 인덱스를 사용해서 다시 두번째 테이블에서 데이터를 찾는다.
>   3.  여기까지 실행되면 모든 데이터를 다찾은 것이고 그다음은 인출(Fetch)를 실행해서 전송한다

<br><br>

## Table Partition

>   ### Partition 기능
>
>   -   파티션은  대용량의 테이블을 여러 개의 데이터 파일에 분리해서 저장한다
>
>   -   #### **효과 **
>
>       -    테이블의 데이터가 물리적으로 분리된 데이터 파일에 저장되면 입력,수정,삭제,조회 성능이 향상된다
>       -   데이터를 조회할 때 데이터의 범위를 줄여서 성능을 향상시킨다
>
>   -   #### **특징**
>
>       -   파티션은 각각의 **파티션 별로 독립적으로 관리**될 수 있다
>       -   파티션 별로 백업하고 복구가 가능하면 **파티션 전용 인덱스 생성도 가능하다**
>       -   파티션은 Oracle 데이터베이스의 논리적 관리 단위인 테이블 스페이스 간에 이동이 가능하다
>
>   ### Partition 종류
>
>   -   #### Range Partition(범위지정)
>
>       -   Range Partition은 테이블의 칼4럼 중에서 **값의 범위를 기준으로 여러 개의 파티션으로 데이터를 나누어 저장**하는 것이다
>
>   -   #### List Partition(특정값지정)
>
>       -   **특정 값을 기준으로 분할**하는 방법
>
>   -   #### Hash Partition(해시 적용)
>
>       -   **데이터베이스 관리 시스템**이 **내부적으로 해시 함수를 사용해서 데이터를 분할**한다
>       -   데이베이스 관리 시스템이 알아서 분할하고 관리하는 것
>
>   -   #### Composite Partition
>
>       -   여러 개의 파티션 기법을 조합해서 사용하는 것
>
>   ### 파티션 인덱스
>
>   -   파티션 인덱스는 4가지 유형의 인덱스를 제공한다
>   -   **Prefixed Index : **파티션 키를 사용해서 인덱스를 만드는 
>   -   **Local Index :** 파티션 별로 각자의 인덱스를 사용하는것
>   -   **Global Index :** 여러 개의 파티션에서 하나의 인덱스를 사용한다 (오라클지원X)
>   -   **Non Prefixed Index :** 파티션 키와 인덱스 키가 다르다 (오라클지원X)

<br><br>

## WITH구문

>   WITH구문은 서브쿼리(Subquery)를 사용해서 임시 **테이블이나 뷰처럼 사용할 수 있는 구문**이다
>
>   서브쿼리가 **여러 번 다시 사용될 때 편리**하게 사용할 수 있다.
>
>   서브쿼리 블록에 **별칭을 지정할 수 있다**
>
>   **옵티마이저는 SQL을 인라인 뷰나 임시 테이블로 판단**한다
>
>   ```mysql
>   WITH viewData(별칭) AS(SELECT * FROM EMP
>   	UNION ALL
>   		SELECT*FROM EMP)
>   		SELECT * FROM viewData(별칭) WHERE EMPNO=10
>   ```





<br><br>

# 함수

<br><br>

## 문자열 함수

| 문자열 함수              | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ASCII(문자)              | 문자 혹은 숫자를 ASCII 코드값으로 변환한다                   |
| CHAR(ASCII 코드값)       | ASCII 코드값을 문자로 변환한다                               |
| SUBSTR(문자열,m,n)       | 문자열에서 m번째 위치부터 n개를 자른다                       |
| CONCAT(문자열1,문자열2)  | -문자열1번과 문자열2번을 결합한다.<br />_Oracle은 '\|\|',MS-SQL은 '+'를 사용할 수 있다. |
| LOWER(문자열)            | 영문자를 소문자로 변환한다                                   |
| UPPER(문자열)            | 영문자를 대문자로 변환한다                                   |
| LENGTH 혹은 LEN(문자열)  | 공백을 포함해서 문자열의 길이를 알려준다                     |
| LTRIM(문자열,지정문자)   | -왼쪽에서 지정된 문자를 삭제한다<br />-지정된 문자를 생략하면 공백을 삭제한다 |
| RTRIM(문자열,지정문자)   | -오른쪽에서 지정된 문자를 삭제한다<br />-지정된 문자를 생략하면 공백을 삭제한다 |
| TRIM(문자열,지정된 문자) | -왼쪽 및 오른쪽에서 지정된 문자를 삭제한다<br />-지정된 문자를 생략하면 공백을 삭제한다 |

<br><br>



## NULL함수

| NULL함수   | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| NVL함수    | - NULL이면 다른 값으로 바꾸는 함수이다<br />-'NVLL(MGR,0)'은 MGR이 NULL이면 0으로 바꾼다 |
| NVL2함수   | -NVL함수와 DECODE함수를 하나로 만든 것이다<br />-'NVL(MGR,1,0)' 은 MGR컬럼이 NULL이 아니면 1을, NULL이면 0을 반환한다 |
| NULLIF함수 | -두 개의 값이 같으면 NULL을, 같지 않으면 첫 번째 값을 반환한다<br />-'NULLIF(exp1,exp2)' 은 exp1과 exp2가 같으면 NULL을, 같지 않으면 exp11을 반환한다 |
| COALESCE   | -NULL이 아닌 최초의 인자 값을 반환한다<br />-'COALESCE(exp1,exp2,exp3...)'은 ex1이 NULL이 아니면 exp1의 값을, 그렇지 않으면 그 뒤에 값의 NULL 여부를 판닪하여 값을 반환한다 |

<br><br>

## 집계함수

| 집계함수      | 설명                       |
| ------------- | -------------------------- |
| COUNT()       | 행 수를 조회한다           |
| SUM()         | 합계를 계산한다            |
| AVG()         | 평균을 계산한다            |
| MAX()와 MIN() | 최댓값과 최솟값을 계산한다 |
| STDDEV()      | 표준편차를 계산한다        |
| VARIAN()      | 분산을 계산한다            |

<br><br>

## 날짜형 함수

| 날짜형 함수                               | 설명                                 |
| ----------------------------------------- | ------------------------------------ |
| SYSDATE                                   | 오늘의 날짜를 날짜 타입으로 알려준다 |
| EXTRACT('YEAR'\|'MONTH'\|'DAY' from dual) | 날짜에서 년,월,일을 조회한다         |

<br><br>

## 숫자형 함수

| 숫자형 함수        | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| ABS(숫자)          | 절댓값을 돌려준다                                            |
| SIGN(숫자)         | 양수,음수,0을 구별한다                                       |
| MOD(숫자1,숫자2)   | -숫자1을 숫자2로 나누어 나머지를 계산한다<br />-%를 사용해도 된다 |
| CEIL/CEILING(숫자) | 숫자보다 크거나 같은 최소의 정수를 돌려준다                  |
| FLOOR()            | 숫자보다 작거나 같은 최대의 정수를 돌려준다                  |
| ROUND(숫자,m)      | -소수점 m  자리에 반올림한다<br />-m의 기본값(Default Value)은 0이다 |
| TRUNC(숫자,m)      | -소수점 m 자리에서 절삭한다<br />-m의 기본값(Default Value)은 0이다 |



## WINDOW함수

>   윈도우 함수는 행과 행 간의 관계를 정의하기 위해서 제공되는 함수이다
>
>   윈도우 함수를 사용해서 순위,합계,평균,행 위치 등을 조작할 수 있다.
>
>   
>
>   ```mysql
>   SELECT WINDOW_FUNCTION(ARGUMENTS)
>   	OVER(PARTITION BY 컬럼
>   		ORDER BY WINDOWING절)
>   ```
>
>   #### 윈도우 함수 구조
>
>   | 구조            | 설명                                                         |
>   | --------------- | ------------------------------------------------------------ |
>   | ARGUMENTS(인수) | 윈도우 함수에 따라서 0~N개의 인수를 설정한다                 |
>   | PARTITION BY    | 전체 집합을 기준에 의해 소그룹으로 나눈다                    |
>   | ORDER BY        | 어떤 항목에 대해서 정렬한다                                  |
>   | WINDOWING       | -행 기준의 범위를 정한다<br />-ROWS는 물리적 결과의 행 수 이고 RANGE는 논리적인 값에 의한 범위이다. |
>
>   #### WINDOWING
>
>   s
>
>   | 구조                | 설명                                                        |
>   | ------------------- | ----------------------------------------------------------- |
>   | ROWS                | 부분집합인 윈도우 크기를 물리적 단위로 행의 집합을 지정한다 |
>   | RANGE               | 논리적인 주소에 의해 행 집합을 지정한다                     |
>   | BETWEEN~AND         | 윈도우의 시작과 끝의 위치를 지정한다                        |
>   | UNBOUNDED PRECEDING | 윈도우의 시작 위치가 첫 번째 행임을 의미한다                |
>   | UNBOUNDED PRECEDING | 윈도우의  마지막 위치가 마지막 행임을 의미한다              |
>   | CURRENT ROW         | 윈도우 시작 위치가 현재 행임을 의미한다                     |
>
>   

### 순위 함수

| 순위 함수  | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| RANK       | -특정항목 및 파티션에 대해서 순위를 계산한다<br />-동일한 순위는 동일한 값이 부연된다 |
| DENSE_RANK | 동일한 순위를 하나의 건수로 계산한다                         |
| ROW_NUMBER | 동일한 순위에 대해서 고유의 순위를 부여한다                  |

### 집계함수

| 집계 함수 | 설명                                   |
| --------- | -------------------------------------- |
| SUM       | 파티션 별로 합계를 계산한다            |
| AVG       | 파티션 별로 평균을 계산한다            |
| COUN      | 파티션 별로 행 수를 계산한다           |
| MAX와 MIN | 파티션 별로 최댓값과 최솟값을 계산한다 |

### 행 순서 관련 함수

-   행 순서 관련 함수는 상위 행의 값을 하위에 출력하거나 하위 행의 값을 상위 행에 출력할 수 있다.
-   특정 위치의 행을 출력할 수 있다.

| 행 순서     | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| FIRST_VALUE | -파티션에서 가장 처음에 나오는 값을 구한다<br />-MIN함수를 사용해서 같은 결과를 구할 수 있다. |
| LAST_VALUE  | -파티션에서 가장 나중에 나오는 값을 구한다<br />-MAX함수를 사용해서 같은 결과를 구할 수 있다 |
| LAG         | 이전 행을 가지고 온다                                        |
| LEAD        | -윈도우에서 특정 위치에 행을 가지고 온다.<br />-기본값은 1이다. |

### 비율 관련 함수

-   비율 관련 함수는 누적 백분율, 순서별 백분율, 파티션을 N분으로 분할한 결과 등을 조회할 수 있다

    -   | 비율 함수설명   | 설명                                                         |
        | --------------- | ------------------------------------------------------------ |
        | CUME_DIST       | -파티션 전체 건수에서 현재 행보다 작거나 같은 겉수에 대한 누적 백분율을 조회한다<br />-누적 분포상에 위치를 0~1사이의 값을 가진다 |
        | PERCENT_RANK    | 파티션에서 제일 먼저 나온 것을 0으로 제일 늦게 나온 것을 1로 하여 값이 아닌 행의 순서별 백분율을 조회한다 |
        | NTILE           | 파티션별로 전체 건수를 ARGUMENT 값으로 N등분한 결과를 조회한다, 높은것부터 1로 시작한다 |
        | RATIO_TO_REPORT | 파티션 내에 전체 SUM(컬럼)에 대한 행 별 칼럼값의 백분율을 소수점까지 조회한다 |

    





# 상황



:book: insert문 작성시 **<u>테이블명 뒤에 특정 속성들을 지정하지 않았으므로 VALUES뒤에는 테이블의 전체 속성값들이 부여되어야한다</u>** 

:book:통합관점의 스키마 구조를 표현한 것을 개념스키마라고 하며 데이터모델링은 통합 관점의 뷰를 가지고 있는 개념스키마를 만들어가는 과정으로 이해할 수 있다

:book: ERD관계 : 관계명, 관계차수 , 관계 선택사양

:book: 분산데이터베이스는 데이터 무겨성에 대한 위협이 있다

:book: 식별자 관계로만 연결될 경우 조인의 복잡성이 증가한다

:book:테이블에 만들 수 있는 인덱스의 수는 제한이 없지만 많이 만들면 부하가 생긴다

:book:자주쓰는 컬럼과 그렇지 않은 칼럼으로 나눠서 성능을 향상 시킬 수 있다

:book:natural join에서 컬럼명을 써주면 에러가 난다

:book: Order by가 정렬하는 시점은 모든 실행이 끝난 후에 데이터를 출력해 주기 바로 전이다.

:book:기본키는 자동으로 오름차순 인덱스가 생성된다

**:book: Hash Join은** 정렬 작업이 없어 정렬이 부담되는 **대량 배치작업에 유리하다.**

:book: Sort Merge Join은 Not Equal Join에서도 사용가능하다 

**:book: Nested Loop Join은 조인 칼럼의 인덱스가 존재해야한다** 

:book:**intersect연산자(교집합)**는 **중복된 행을 하나의 행으로 표시**한다

:book: Group by 구문과 Window function은 병행하여 사용할 수 없다

:book: Window function 처리로 결과 건수가 줄어들지는 않는다.

:book: sum,max,min 등과 같은 집계 window function 을 사용할 때 window절과 함께 사용하면 집계의 대상이 되는 레코드 범위를 지정할 수 있다.

